# CString

C module for working with dynamic strings.

## Working of CString

**CString** works by initialising a **"String" Data Structure** which is defined in **CString module**. **"String"** is basically a **struct** which contains **three fields**.

The first field is **"str"** which is of **char pointer type** and stores the **actual character data**. **"str" is stored in the heap memory** and is allocated and controlled using **malloc(), realloc() and free()**, just like other data present in the **heap memory**.

The second field is **"ulen"** which is of **'int' type** and stores the **number of characters filled in the allocated heap memory**.

The third field is **"alen"** which is of **'int' type** and stores the **number of characters allocated to char pointer "str" in the heap memory**.

**'ulen'** and **'alen'** field is maintained by the **CString Module** automatically as and when required.

While adding a **character/"String"**, the module **checks if "ulen" is less than "alen"**. If it is not, then the module **calls realloc() and adds the required memory along with a standard buffer memory of 512 bytes** to the **"str" pointer**.

This allows the module user to **freely add as many characters as the user likes** making it a **dynamic string**.

**Please do note that even though this module protects from attacks like Buffer Overflow, Stack Overflow, etc., it is still the responsibility of the module user to manage heap memory as the module will keep calling realloc() and adding memory to the "str" pointer until Memory Overflow happens, in which case the "str" pointer will be removed.**

## Installation

Simply include the **"cstring.h"** file in your program.

## Usage

Simply use this code (Modify according to your needs):

```C
#include <stdio.h>
#include "cstring.h"

void main()
{
    String str = newString(0); //newString() will be explained in detail in the functions section.
}
```

<!--
### Parameters

- **public_key (Optional):** Public Key to be used if you want to use existing key (Default: "").
- **private_key (Optional):** Private Key to be used if you want to use existing key (Default: "").
- **save (Optional):** Should be true/false. Specifies whether the keys have to be stored in a file or not (Default: true).
- **key_path (Optional):** Specifies the path and name of the file where the keys have to be stored, if save = true (Default: root of your java projct)**(NOTE: Default value won't work in Android Project)**.
- **new (Optional):** Should be true/false. Specifies whether it should ignore any existing key pairs and generate new key pair or not (Default: false).

## Functions

### keys()

```java
Map keys = e2e.keys();
```

Returns Private Key and Public Key in the form of Map of the format {"public": %YOUR_PUBLIC_KEY%, "private": %YOUR_PRIVATE_KEY%}.

### encrypt(String message, String public_key)

```java
String message = "Multicrypt algorithm is highly secure!";
String public_key = keys.get("public");
String encrypted_message = e2e.encrypt(message, public_key);
```

Encrypts the message using MULTICRYPT algorithm.

**Parameters**

- **message (Required):** Message to encrypt.
- **public_key (Required):** Public Key of the recipient of the message (for the asymmetric encryption part).


### decrypt(String message, String private_key)

```java
String private_key = keys.get("private");
String actual_message = e2e.decrypt(encrypted_message, private_key);
```

Decrypts the encrypted message using MULTICRYPT algorithm.

**Parameters**

- **message (Required):** Encrypted Message to decryt.
- **private_key (Optional):** Your Private Key required to decrypt any message which is encrypted with Public Key linked to that private key (Default: Key which was either passed in the parameters map or generated by the program for you).

Useful for transmitting data securely between 2 devices on a network.
-->
